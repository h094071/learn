##1.基础
#MIME 类型:
- HTML 格式的文本文档由 text/html 类型来标记。
- 普通的 ASCII 文本文档由 text/plain 类型来标记。
- JPEG 格式的图片为 image/jpeg 类型。
- GIF 格式的图片为 image/gif 类型。
#URN
>URI 的第二种形式就是统一资源名（ URN）。 URN 是作为特定内容的唯一名称使用
的， 与目前的资源所在地无关。 
#http版本
-1.0：持久的 keep-alive 连接、 虚拟主机支持， 以及代理连接支持
-1.1：校正 HTTP 设计中的结构性缺陷， 明确语义， 引入重要
的性能优化措施

##TCP事务的时延
>TCP 连接建立握手:重用现存连接
延迟确认:TCP捎带确认
TCP慢启动
Nagle 算法
>>试图在发送一个分组之前， 将大量TCP 数据绑定在一起， 以提高网络效率
Nagle 算法鼓励发送全尺寸
HTTP 应用程序常常会在自己的栈中设置参数 TCP_NODELAY， 禁用 Nagle 算法，
提高性能。
TIME_WAIT累积与端口耗尽
>>当某个 TCP 端点关闭 TCP 连接时， 会在内存中维护一个小的控制块，， 用来记录最
近所关闭连接的 IP 地址和端口号。 这类信息只会维持一小段时间,以确保在这段时间内
不会创建具有相同地址和端口号的新连接。

#HTTP连接的处理
>串行事务处理时延
并行连接 浏览器(并行链接数，限制在较小的值) 
持久连接：
>>HTTP/1.1 持久连接在默认情况下是激活
的。 除非特别指明， 否则 HTTP/1.1 假定所有连接都是持久的。 要在事务处理结束
之后将连接关闭， HTTP/1.1 应用程序必须向报文中显式地添加一个 Connection:
close 首部。 
1.只有当连接上所有的报文都有正确的、 自定义报文长度时——也就是说， 实体主
体部分的长度都和相应的 Content-Length 一致， 或者是用分块传输编码方式
编码的——连接才能持久保持
2.HTTP/1.1 应用程序必须能够从异步的关闭中恢复出来。 只要不存在可能会累积
起来的副作用， 客户端都应该重试这条请求。
3.一个用户客户端对任何服务器或代理最多只能维护两条持久连接， 以防服务器过
载。 
>管道化连接
>>在响应到达之前， 可以将多条请求放入队列。
1.如果 HTTP 客户端无法确认连接是持久的， 就不应该使用管道。
2.必须按照与请求相同的顺序回送 HTTP 响应。 HTTP 报文中没有序列号标签， 因
此如果收到的响应失序了， 就没办法将其与请求匹配起来了。
3.HTTP 客户端必须做好连接会在任意时刻关闭的准备， 还要准备好重发所有未完
成的管道化请求。 
4.HTTP 客户端不应该用管道化的方式发送会产生副作用的请求（ 比如 POST）
##幂等:如果一个事务， 不管是执行一次还是很多次， 得到的结果都相同

#HTTP结构

##Web服务器
  建立连接,建立连接,处理请求,访问资源,构建响应,发送响应
##重定向
  永久搬离的资源(301),临时搬离的资源(303)(307),URL 增强(303)(307),
  负载均衡(303)(307),服务器关联(303)(307)规范目录名称

##代 理
###代理作用
  儿童过滤器 文档访问控制 安全防火墙 Web 缓存 反向代理 内容路由器  转码器 匿名者
###代理位置
  出口代理，访问（ 入口）代理，反向代理 网络交换代理
  反向代理通常会直接冒用 Web 服务器的名字和 IP 地址， 这样所有的请求就会被
发送给代理而不是服务器了
  网络交换代理:可以将具有足够处理能力的代理放在网络之间的因特网对等交换点上， 通过缓存
来减轻因特网节点的拥塞， 并对流量进行监视
##缓存
区分命中和未命中的情况 Date 首部的值与当前时间进行比较
内容路由器:代理缓存会决定选择何种路由对内容进行访问、 管理和传送
##缓存的处理步骤
接收 解析 查询 新鲜度检测 创建响应(新的首部和已缓存的主体) 发送 日志
##文档过期
通过特殊的 HTTP Cache-Control 首部和 Expires 首部， HTTP 让原始服务器向
每个文档附加了一个“ 过期日期”。 
服务器用 HTTP/1.0+ 的 Expires 首部或 HTTP/1.1 的 Cache-Control: max-age 响应首
部来指定过期日期
服务器再验证

##用条件方法进行再验证
>HTTP 允许缓存向原始服务器发送一个“ 条件 GET”， 请求服务器只有在文档与缓存中现有的副本不同时， 才回送对象主
体。
If-Modified-Since:Date再验证 true get date ; false get 304 not modified
If-None-Match： 实体标签再验证
强弱验证器 HTTP/1.1 支持“ 弱验证器”  服务器会用前缀“ W/” 来标识弱验证器。
[ETag: W/"v2.6 If-None-Match: W/"v2.6"]
如果 HTTP/1.1 缓存或服务器收到的请求既带有 If-Modified-Since， 又带有实体
标签条件首部， 那么只有这两个条件都满足时， 才能返回 304 Not Modified 响应。
##控制缓存的能力
>Cache-Control: no-store
Cache-Control: no-cache
Cache-Control: must-revalidate
Cache-Control: max-age 
Expires

[http1.0] Pragma: no-cache 
[http1.1]Cache-Control: no-store Cache-Control: no-cache 
使用前必须进行新鲜度再验证 

max-age 新鲜状态的秒数
Cache-Control: max-age=3600

Expires
不推荐使用
实际的过期日期而不是秒数 很多服务器的时钟都不同步， 或者不正确

must-revalidate
可以配置缓存， 使其提供一些陈旧（ 过期） 的对象， 以提高性能。 如果原始服务器
希望缓存严格遵守过期信息， 可以在原始响应中附加一个 Cache-Control: mustrevalidate 首部。

试探性过期

##缓存和广告
配置缓存， 每次访问时都与原始服务器进行再验证
日志迁移
命中计数和使用限制 : HTTP 中添加了一个称为 Meter 的首部， 这个首部会周期性地将对特定
URL 的命中次数回送给服务器
#集成点： 网关、 隧道及中继
##网关
网关可以作为某种翻译器使用， 它抽象出了一种能够到达资源的方法。 网关是资源和应用程序之间的粘合
剂。 
>协议网关 
HTTP/*： 服务器端Web网关
HTTP/HTTPS： 服务器端安全网关
HTTPS/HTTP客户端安全加速器网关
资源网关
#识别、 认证与安全
##cookie机制
会话 cookie 和持久 cookie
不可缓存的内容：Cache-Control:no-cache="Set-Cookie"
可缓存的内容： Cache-Control:public，
#基本认证机制
>基本认证将（ 由冒号分隔的） 用户名和密码打包在一起， 并用 Base-64 编码
方式对其进行编码。 
代理认证:通过代理进行认证
摘要认证（算法：md5）：1、服务器向客户端发起质询， 询问用户名和摘要形式的密码。
2、客户端传递了密码的摘要， 证明它是知道密码的
用随机数防止重放攻击:1、服务器将这个随机数放在 WWW-Authenticate 质询报文中， 与服务器所支持的算法列表一同发
往客户端。
1. 预先生成下一个随机数
2. 受限的随机数重用机制
2. 受限的随机数重用机制

非对称加密算法：RSA
但公开密钥加密算法的计算可能会很慢。 实际上它混合使用了对称和非对称策略。
比如， 比较常见的做法是在两节点间通过便捷的公开密钥加密技术建立起安全通信，
然后再用那条安全的通道产生并发送临时的随机对称密钥， 通过更快的对称加密技
术对其余的数据进行加密。

#XSS 与 CSRF 两种跨站攻击
XSS：跨站脚本（Cross-site scripting）
CSRF：跨站请求伪造（Cross-site request forgery）

##XSS 全称“跨站脚本”，是注入攻击的一种。其特点是不对服务器端造成任何伤害，而是通过一些正常的站内交互途径，例如发布评论，提交含有 JavaScript 的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本。
我们知道 AJAX 技术所使用的 XMLHttpRequest 对象都被浏览器做了限制，只能访问当前域名下的URL，所谓不能“跨域”问题。这种做法的初衷也是防范XSS，多多少少都起了一些作用，但不是总是有用
如果我们不需要用户输入 HTML 而只想让他们输入纯文本，那么把所有用户输入进行 HTML 转义输出是个不错的做法。似乎很多 Web 开发框架、模版引擎的开发者也发现了这一点，Django 内置模版和 Jinja2 模版总是默认转义输出变量的 。Django 内置模版和 Jinja2 模版总是默认转义输出变量的

##CSRF：冒充用户之手
XSS 是实现 CSRF 的诸多途径中的一条，但绝对不是唯一的一条。一般习惯上把通过 XSS 来实现的 CSRF 称为 XSRF。